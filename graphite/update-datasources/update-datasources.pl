#!/usr/bin/perl -w
#
# $Id: update-datasources.pl 399 2008-08-22 03:51:07Z jaym $
#
# NAME
#       update-datasources.pl - perl script to sync rrd files with zGraphs DB
#
# DESCRIPTION
#       Script to sync the rrd files generated by Zenoss with the
#       datasources database for the zGraphs
#
#       A cron job is running every 5 minutes to compare the directory listing
#       of the Zenoss generated rrd files (/opt/zenoss/perf/Devices) with a 
#       file containing the full list of that directory.
#
#       Any differences will then be processed by this script.
#       If there are no differences since the last run the script will exit.
#
#       If there are differences this script stores those in the DB for the
#       zGraphs (http://stats.al.com.au) and then populates the full.list
#       with the latest directory listing of /opt/zenoss/perf/Devices
#
# AUTHOR
#       Jay Munzner. Copyright 2009 Dr D Studios

use strict;
use File::Find;
use Data::Dumper;
use XML::LibXML;
use DBI;
$Data::Dumper::Indent = 1;

# DB connection vars
my $dsn = 'DBI:mysql:noc:localhost';
my $db_user = 'noc';
my $db_pass = 'noc';
my $dbh = DBI->connect($dsn, $db_user, $db_pass);

# File::Find vars
my $dir = "/opt/zenoss/perf/Devices";
my $id  = 0;

# Other file locations
my $fulllist   = "/usr/local/bin/update-datasources/full.list";
my $updatelist = "/usr/local/bin/update-datasources/update.list";

# XML vars
my $xml = "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n<directory name=\"$dir\">\n";

#
# Subroutines
#
sub add_nodes {
  my ($node, $parent_id) = @_;

  # Prepare the sql statement
  my $sth = $dbh->prepare(qq{
    select id from datasources
      where name = ? and parent_id = ?
  });

  # Check if there is already an entry for this element
  $sth->execute($node->getAttribute('name'), $parent_id);
  $parent_id = ($sth->rows > 0) ? $sth->fetchrow_array() : 0;

  # Go through the directories
  foreach my $directory ($node->getChildrenByTagName('directory')) {
    my $directory_id;
    my $directory_name = $directory->getAttribute('name');

    # Check if directory already exists
    $sth->execute($directory_name, $parent_id);
    if ($sth->rows > 0) {
      $directory_id = $sth->fetchrow_array();
    } else {
      print "Adding Directory $directory_name\n";

      # No entry exists, add it and store new Id
      $dbh->do("insert into datasources values (\"\", \"$directory_name\", NULL, \"folder\", $parent_id)");
      $directory_id = $dbh->{q{mysql_insertid}};
    }

    # Go through datasources, if they exist
    foreach my $datasource ($directory->getChildrenByTagName('datasource')) {
      my $datasource_name = $datasource->getAttribute('name');
      my $datasource_rrd  = $datasource->getAttribute('rrd');

      # Check if datasource already exists
      $sth->execute($datasource_name, $directory_id);
      if ($sth->rows == 0) {
        print "Adding Datasource $datasource_name\n";

        # Just insert, no need to store id, since this is a datasource
        $dbh->do("insert into datasources values (\"\", \"$datasource_name\", \"$datasource_rrd\", \"datasource\", $directory_id)");
      }
    }
    $sth->finish();

    add_nodes($directory, $parent_id);
  }
}

sub generate_xml {
  my ($hash, $xml) = @_;

  while ( (my $key, my $value) = each(%{$hash}) ) {

    if ( ref($value) eq 'HASH' ) {
      $$xml .= "<directory name=\"$key\">\n";

      generate_xml($hash->{$key}, $xml);
    } else {

      # Get the name of the ds
      my ($datasource, $extension) = split(/\./, $key);
      
      # Check if extension is .rrd
      next if (!defined($extension) || $extension !~ /rrd/);

      # Split to get the name
      my ($tmp, @name) = split(/_/, $datasource); 

      # Split the path to get the machine name - very specific for now
      my (undef, $opt, $zenoss, $perf, $devices, $hostname, @rest) = split(/\//, $value);

      # Special cases for interfaces, os, virtualmachines
			my $special = '';
			if (defined($rest[2])) {

				# Virtual Machines
				$special .= '_' . $rest[1] if ($rest[0] eq 'virtualmachines');

				# Interfaces, OS
				$special .= '_' . $rest[2] if ($rest[0] eq 'interface' || $rest[0] eq 'os');
			}

      # Split fqdn to get host only
      my ($host, undef, undef, undef, undef) = split(/\./, $hostname);
      $host =~ s/-/_/g;

      $$xml .= "<datasource name=\"" . $host . $special . "_" . join('_', @name) . "\" rrd=\"$value\" />\n";
    }
  }
  $$xml .= "</directory>\n";
}

sub update_tree {
  my $node = $_[0] = {};

  # Open the update list
  open UPDATE, $updatelist or die "Couldn't open file: $!";
  my @paths = <UPDATE>;
  close UPDATE;

  # Loop over array and generate hash
  foreach my $path (@paths) {
    chomp($path);

    # Skip line if it does not contain path to rrd file
    next if $path !~ /\.rrd/;

    # Replace root dir (/opt/zenoss/perf/Devices)
    $path =~ s/$_[1]\///;

    my @path = split(/\//, $path);
    my $tree_str = "\$node";

    foreach my $element (@path) {
       $tree_str .= "->{'$element'}";
    }

    my $value = ($path[$#path] =~ /\.rrd$/) ? "'$_[1]/$path'" : "{}";
    eval "$tree_str = $value";
  }
}


# This function is used to get the initial tree into a hash
# Subsequent updates are much faster when run through update_tree
sub build_tree {
  my $node = $_[0] = {};
  my @s;
  find( sub {
    $node = (pop @s)->[1] while @s and $File::Find::dir ne $s[-1][0];

    return $node->{$_} = $File::Find::name if -f;

    push @s, [ $File::Find::name, $node ];
    $node = $node->{$_} = {};
  }, $_[1]);
  $_[0]{$_[1]} = delete $_[0]{'.'};
}

#
# Main Routine
#

# Check if any updates are necessary
# If the update file is empty there is nothing to do
exit 0 if ! -s $updatelist;

# Build initial hash from filesystem
#build_tree(my $tree, $dir);

# Update tree from filesystem
update_tree(my $tree, $dir);

# Generate the xml
generate_xml($tree, \$xml);

# Add nodes to db - via xml parse
my $parser = XML::LibXML->new();
my $xtree  = $parser->parse_string($xml);
add_nodes($xtree->getDocumentElement, 0);

# Once all this is done, update the full.list to make it up-to-date
system("find $dir > $fulllist");
